---
dg-publish: true
---
A collection of runtime process-level mitigation features, formerly known as Enhanced Mitigation Experience Toolkit (EMET). Configurable via an [XML policy frontend](https://learn.microsoft.com/en-us/defender-endpoint/exploit-protection-reference) for [RtlSetImageMitigationPolicy](https://learn.microsoft.com/en-us/windows/win32/debug/rtlsetimagemitigationpolicy-function). Pretty much the user-configurable subset of [SetProcessMitigationPolicy](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy).
## Export
Forget what I wrote this for, might've been testing which mitigations worked system-wide
```powershell
Get-ProcessMitigation -System | select -ExcludeProperty ProcessName, Source, Id | ¬†% {'<SystemConfig>'} {
¬† $_.psobject.properties | % {" ¬†<$($_.name) $(
¬† ¬† $_.value.psobject.properties | % { $_.name+'="'+$_.value+'"' }
¬† ) />"}
} {'</SystemConfig>'}
```
## Schema
I wanted an XML policy schema for some codegen but couldn't find one, so I got to carving. `Microsoft.ProcessMitigations.Commands.dll` implements the PowerShell cmdlets so it seemed like a good place to start. ILSpy made quick work of them, they're just calling the win32 [MitigationConfiguration.dll](https://strontic.github.io/xcyclopedia/library/MitigationConfiguration.dll-159290A4FDB80AF51017DAAFA4FE58F8.html) (like `ValidateXMLFromManaged(path)`). 

It's pretty easy to call from PowerShell, but I don't really want to rely on Windows.

```powershell
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;

public class MitigationConfig
{
    [DllImport("MitigationConfiguration.dll", CharSet = CharSet.Auto)]
    public static extern int ValidateXMLFromManaged(string fileName, ref bool result);
}
"@

$result = $false
$hr = [MitigationConfig]::ValidateXMLFromManaged("ExploitGuard.xml", [ref]$result)
Write-Host "Return code: $hr, Result: $result"
```

`ValidateXMLFromManaged` makes me think the DLL might have a schema somewhere. Strings didn't find anything,`Get-Content -Encoding unicode` was better - the XML properties were present, but as UTF-16 space-separated strings? With no types or anything. Time to pull out Ghidra.

It's COM... The decomp is gross, but it's pretty much just calling [IXMLDOMDocument2](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms761358(v=vs.85)).loadXML with XML validation enabled. No schema validation in sight, despite the [cmdlet arg mentioning an xsd](https://learn.microsoft.com/en-us/powershell/module/processmitigations/set-processmitigation?view=windowsserver2025-ps#-isvalid), so I guess I'll build a schema myself.

```cpp
IXMLDOMDocument2 *xmlDoc = NULL;
hr = CoCreateInstance(&CLSID_DOMDocument60, NULL, CLSCTX_INPROC_SERVER, &IID_IXMLDOMDocument2, (void**)&xmlDoc);
hr = xmlDoc->put_async(VARIANT_TRUE);
hr = xmlDoc->put_validateOnParse(VARIANT_TRUE);
hr = xmlDoc->put_resolveExternals(VARIANT_TRUE);
...
hr = xmlDoc->load(xmlVariant.bstrVal, &parseResult);
```

Those strings I was seeing were only used in `ImportMitigation`, not validation.

[Florian's great policy](https://github.com/Harvester57/Exploit-Protection-policy) was really helpful for testing, but his system-wide mitigations included some that are per-app-only in the [docs](https://learn.microsoft.com/en-us/defender-endpoint/customize-exploit-protection#exploit-protection-mitigations), so I left an [issue](https://github.com/Harvester57/Exploit-Protection-policy/issues/11). Turns out the docs are just wrong.
My tooling (and skill lol) isn't good enough for a clean decomp of the C++ objects in `ImportMitigation`, but I suspect it's just passing parsed data straight to [RtlSetImageMitigationPolicy](https://learn.microsoft.com/en-us/windows/win32/debug/rtlsetimagemitigationpolicy-function) and letting it do validation. Hard to tell for sure without making a Ghidra type for [IXmlReader](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms752743\(v=vs.85\)) and I really can't be bothered ü§∑‚Äç‚ôÇÔ∏è

I did notice PowerShell cmdlet `Set-ProcessMitigation` has a hardcoded blocklist, for mitigations that aren't supported system-wide. But thanks to [winbindex](https://winbindex.m417z.com/?file=microsoft.processmitigations.commands.dll) I can see it hasn't been updated since at least 1809.

```C#
private string[] BlockInSystemMode = new string[14]  
{  
	"EnableExportAddressFilter", "AuditEnableExportAddressFilter", "EnableExportAddressFilterPlus", "AuditEnableExportAddressFilterPlus", "EnableImportAddressFilter", "AuditEnableImportAddressFilter", "EnableRopStackPivot", "AuditEnableRopStackPivot", "EnableRopCallerCheck", "AuditEnableRopCallerCheck",  
	"EnableRopSimExec", "AuditEnableRopSimExec", "DisallowChildProcessCreation", "AuditChildProcess"  
};
```